name: Publish from version commit

on:
  push:
    branches: [ main, master ]

permissions:
  contents: write
  packages: write

jobs:
  check:
    name: Check commit message for version
    runs-on: ubuntu-latest
    outputs:
      publish: ${{ steps.decide.outputs.publish }}
      version: ${{ steps.decide.outputs.version }}
      release_body: ${{ steps.decide.outputs.release_body }}
      commit_sha: ${{ steps.decide.outputs.commit_sha }}
    steps:
      - uses: actions/checkout@v4

      - name: Get latest commit message (subject only)
        id: get_message
        run: |
          commit_message="$(git log -1 --pretty=%s | tr -d '\r' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
          echo "commit_message=$commit_message" >> "$GITHUB_OUTPUT"

      - name: Decide whether to publish
        id: decide
        run: |
          commit_message="${{ steps.get_message.outputs.commit_message }}"
          if echo "$commit_message" | grep -qE '^v?[0-9]+\.[0-9]+\.[0-9]+'; then
            ver=$(echo "$commit_message" | grep -oE '^v?[0-9]+\.[0-9]+\.[0-9]+' | head -n1)
            if [[ $ver != v* ]]; then ver="v$ver"; fi
            echo "publish=true" >> "$GITHUB_OUTPUT"
            echo "version=$ver" >> "$GITHUB_OUTPUT"
            echo "release_body=$commit_message" >> "$GITHUB_OUTPUT"
            echo "commit_sha=$(git rev-parse HEAD)" >> "$GITHUB_OUTPUT"
          else
            echo "publish=false" >> "$GITHUB_OUTPUT"
            echo "version=" >> "$GITHUB_OUTPUT"
            echo "release_body=" >> "$GITHUB_OUTPUT"
            echo "commit_sha=" >> "$GITHUB_OUTPUT"
          fi

      - name: Verify version consistency
        if: ${{ steps.decide.outputs.publish == 'true' }}
        id: verify_version
        run: |
          # read version from internal/version/version.go
          FILE_VER=$(perl -ne 'if(/var\s+Version\s*=\s*"([^"]+)"/){print $1; exit}' internal/version/version.go || true)
          if [ -z "$FILE_VER" ]; then
            echo "Could not read version from internal/version/version.go; aborting" >&2
            exit 1
          fi
          # normalize expected version from commit message
          EXP_VER="${{ steps.decide.outputs.version }}"
          if [[ $EXP_VER != v* ]]; then EXP_VER="v$EXP_VER"; fi
          if [[ "$FILE_VER" != "$EXP_VER" ]]; then
            echo "Version mismatch: commit message version is $EXP_VER but internal/version/version.go contains $FILE_VER" >&2
            exit 1
          fi
          echo "Version consistency check passed: $FILE_VER"

  build-and-publish:
    name: Build and publish
    needs: check
    if: needs.check.outputs.publish == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.22'

      - name: Build distributions (portable)
        run: |
          set -euo pipefail
          mkdir -p dist
          # Read version from internal/version/version.go and use it as source of truth
          FILE_VER=$(perl -ne 'if(/var\s+Version\s*=\s*"([^"]+)"/){print $1; exit}' internal/version/version.go || true)
          if [ -z "$FILE_VER" ]; then
            echo "Could not read version from internal/version/version.go; aborting" >&2
            exit 1
          fi
          echo "Using version from version.go: $FILE_VER"
          VERSION_NO_V="${FILE_VER#v}"

          targets=("linux/amd64" "linux/arm64" "darwin/amd64" "darwin/arm64" "windows/amd64" "windows/arm64")
          for t in "${targets[@]}"; do
            os=${t%%/*}
            arch=${t##*/}
            ext=""
            if [ "$os" = "windows" ]; then ext=".exe"; fi
            out="dist/krnr-${VERSION_NO_V}-${os}-${arch}${ext}"
            echo "Building $out"
            env GOOS=$os GOARCH=$arch CGO_ENABLED=0 go build -ldflags "-X github.com/VoxDroid/krnr/internal/version.Version=${VERSION_NO_V}" -o "$out" .
          done

          # Create portable archives (named with '-portable') next to the binaries
          mkdir -p dist/portable
          for f in dist/krnr-${VERSION_NO_V}-*; do
            base=$(basename "$f")
            if [[ "$base" == *.exe ]]; then
              echo "Creating ZIP portable for $base"
              zip -j "dist/${base%.*}-portable.zip" "dist/$base" LICENSE README.md || true
            else
              echo "Creating tar.gz portable for $base"
              tar -C dist -czf "dist/${base}-portable.tar.gz" "$base" LICENSE README.md || true
            fi
          done

          # Move raw binaries into an artifacts subdir for cleanliness
          mkdir -p dist/portable/binaries
          mv dist/krnr-${VERSION_NO_V}-* dist/portable/binaries/ || true

      - name: Require PERSONAL_TOKEN
        run: |
          if [ -z "${{ secrets.PERSONAL_TOKEN }}" ]; then
            echo "PERSONAL_TOKEN secret is required to create a release under your account. Add it to repository secrets and re-run." >&2
            exit 1
          fi

      - name: Create GitHub Release and upload artifacts
        uses: ncipollo/release-action@v1
        with:
          token: ${{ secrets.PERSONAL_TOKEN }}
          tag: ${{ needs.check.outputs.version }}
          name: ${{ needs.check.outputs.version }}
          body: ${{ needs.check.outputs.release_body }}
          artifacts: "dist/*"
          draft: false
          prerelease: false
