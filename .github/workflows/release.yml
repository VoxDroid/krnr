name: Publish from version commit

on:
  push:
    branches: [ main, master ]

permissions:
  contents: write
  packages: write

jobs:
  check:
    name: Check commit message for version
    runs-on: ubuntu-latest
    outputs:
      publish: ${{ steps.decide.outputs.publish }}
      version: ${{ steps.decide.outputs.version }}
      release_body: ${{ steps.decide.outputs.release_body }}
      commit_sha: ${{ steps.decide.outputs.commit_sha }}
    steps:
      - uses: actions/checkout@v4

      - name: Get latest commit message (subject only)
        id: get_message
        run: |
          commit_message="$(git log -1 --pretty=%s | tr -d '\r' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
          # safe base64-encoded output to avoid quote injection when used in later shell blocks
          commit_message_b64=$(printf '%s' "$commit_message" | base64 -w0)
          echo "commit_message_b64=$commit_message_b64" >> "$GITHUB_OUTPUT"

      - name: Decide whether to publish
        id: decide
        run: |
          # decode base64 commit message safely
          commit_message=$(printf '%s' "${{ steps.get_message.outputs.commit_message_b64 }}" | base64 --decode)
          if echo "$commit_message" | grep -qE '^v?[0-9]+\.[0-9]+\.[0-9]+'; then
            ver=$(echo "$commit_message" | grep -oE '^v?[0-9]+\.[0-9]+\.[0-9]+' | head -n1)
            if [[ $ver != v* ]]; then ver="v$ver"; fi
            echo "publish=true" >> "$GITHUB_OUTPUT"
            echo "version=$ver" >> "$GITHUB_OUTPUT"
            echo "release_body=$commit_message" >> "$GITHUB_OUTPUT"
            echo "commit_sha=$(git rev-parse HEAD)" >> "$GITHUB_OUTPUT"
          else
            echo "publish=false" >> "$GITHUB_OUTPUT"
            echo "version=" >> "$GITHUB_OUTPUT"
            echo "release_body=" >> "$GITHUB_OUTPUT"
            echo "commit_sha=" >> "$GITHUB_OUTPUT"
          fi

      - name: Verify version consistency
        if: ${{ steps.decide.outputs.publish == 'true' }}
        id: verify_version
        run: |
          # read version from internal/version/version.go
          FILE_VER=$(perl -ne 'if(/var\s+Version\s*=\s*"([^"]+)"/){print $1; exit}' internal/version/version.go || true)
          if [ -z "$FILE_VER" ]; then
            echo "Could not read version from internal/version/version.go; aborting" >&2
            exit 1
          fi
          # normalize expected version from commit message
          EXP_VER="${{ steps.decide.outputs.version }}"
          if [[ $EXP_VER != v* ]]; then EXP_VER="v$EXP_VER"; fi
          if [[ "$FILE_VER" != "$EXP_VER" ]]; then
            echo "Version mismatch: commit message version is $EXP_VER but internal/version/version.go contains $FILE_VER" >&2
            exit 1
          fi
          echo "Version consistency check passed: $FILE_VER"

  build-and-publish:
    name: Build and publish
    needs: check
    if: needs.check.outputs.publish == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.25.5'

      - name: Build distributions (portable)
        run: |
          set -euo pipefail
          mkdir -p dist
          # Read version from internal/version/version.go and use it as source of truth
          FILE_VER=$(perl -ne 'if(/var\s+Version\s*=\s*"([^"]+)"/){print $1; exit}' internal/version/version.go || true)
          if [ -z "$FILE_VER" ]; then
            echo "Could not read version from internal/version/version.go; aborting" >&2
            exit 1
          fi
          echo "Using version from version.go: $FILE_VER"
          VERSION_NO_V="${FILE_VER#v}"

          targets=("linux/amd64" "linux/arm64" "darwin/amd64" "darwin/arm64" "windows/amd64" "windows/arm64")
          for t in "${targets[@]}"; do
            os=${t%%/*}
            arch=${t##*/}
            ext=""
            if [ "$os" = "windows" ]; then ext=".exe"; fi
            out="dist/krnr-${VERSION_NO_V}-${os}-${arch}${ext}"
            echo "Building $out"
            env GOOS=$os GOARCH=$arch CGO_ENABLED=0 go build -ldflags "-X github.com/VoxDroid/krnr/internal/version.Version=${VERSION_NO_V}" -o "$out" .
          done

          # Create portable archives (named with '-portable') next to the binaries
          mkdir -p dist/portable
          for f in dist/krnr-${VERSION_NO_V}-*; do
            base=$(basename "$f")
            if [[ "$base" == *.exe ]]; then
              echo "Creating ZIP portable for $base"
              zip -j "dist/${base%.*}-portable.zip" "dist/$base" LICENSE README.md || true
            else
              echo "Creating tar.gz portable for $base"
              tar -C dist -czf "dist/${base}-portable.tar.gz" "$base" LICENSE README.md || true
            fi
          done

          # Move raw binaries into an artifacts subdir for cleanliness
          mkdir -p dist/portable/binaries
          mv dist/krnr-${VERSION_NO_V}-* dist/portable/binaries/ || true

      - name: Require PERSONAL_TOKEN
        run: |
          if [ -z "${{ secrets.PERSONAL_TOKEN }}" ]; then
            echo "PERSONAL_TOKEN secret is required to create a release under your account. Add it to repository secrets and re-run." >&2
            exit 1
          fi

      - name: Create annotated tag for release
        if: ${{ needs.check.outputs.publish == 'true' }}
        env:
          GITHUB_REPO: ${{ github.repository }}
          PERSONAL_TOKEN: ${{ secrets.PERSONAL_TOKEN }}
        run: |
          set -euo pipefail
          VERSION="${{ needs.check.outputs.version }}"
          echo "Creating and pushing tag $VERSION"
          git config user.name "VoxDroid"
          git config user.email "izeno.contact@gmail.com"
          git tag -a "$VERSION" -m "Release $VERSION"
          git push "https://x-access-token:${PERSONAL_TOKEN}@github.com/${GITHUB_REPO}" "$VERSION"

      - name: Install GoReleaser
        if: ${{ needs.check.outputs.publish == 'true' }}
        run: |
          curl -sSfL https://github.com/goreleaser/goreleaser/releases/latest/download/goreleaser_Linux_x86_64.tar.gz | tar xz -C /tmp
          sudo mv /tmp/goreleaser /usr/local/bin/

      - name: Run GoReleaser (publish)
        if: ${{ needs.check.outputs.publish == 'true' }}
        env:
          GITHUB_TOKEN: ${{ secrets.PERSONAL_TOKEN }}
        run: |
          set -euo pipefail
          echo "Removing old dist/ and running GoReleaser to build and publish artifacts"
          rm -rf dist || true
          # Write release notes to a temp file to ensure GoReleaser reads them as content (not a filename).
          NOTES_FILE="$(mktemp)"
          echo "Release ${{ needs.check.outputs.version }}: ${{ needs.check.outputs.release_body }}" > "$NOTES_FILE"
          goreleaser release --release-notes "$NOTES_FILE" --snapshot=false

      - name: Confirm published artifacts
        if: ${{ needs.check.outputs.publish == 'true' }}
        run: |
          echo "Listing generated artifacts in dist/"
          ls -la dist || true
          echo "GoReleaser should have published these to the GitHub Release and registries configured in .goreleaser.yml"
