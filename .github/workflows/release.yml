name: Publish from version commit

on:
  push:
    branches: [ main, master ]
    # Also trigger on tag pushes like v1.0.0 so releases can be created from tags
    tags: [ 'v*' ]

permissions:
  contents: write
  packages: write

jobs:
  check:
    name: Check commit message for version
    runs-on: ubuntu-latest
    outputs:
      publish: ${{ steps.decide.outputs.publish }}
      version: ${{ steps.decide.outputs.version }}
      release_body: ${{ steps.decide.outputs.release_body }}
      commit_sha: ${{ steps.decide.outputs.commit_sha }}
    steps:
      - uses: actions/checkout@v4
        with:
          # fetch full history and tags so we can inspect tags and head commits
          fetch-depth: 0

      - name: Get latest commit message (subject only)
        id: get_message
        run: |
          # Ensure tags are available locally (in case workflow triggered by tag push)
          git fetch --tags || true

          commit_message="$(git log -1 --pretty=%s 2>/dev/null | tr -d '\r' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"

          # If commit subject is empty (detached/tag push), try to obtain annotated tag message
          if [ -z "$commit_message" ]; then
            # If there's a tag pointing to HEAD, use its annotation message (if annotated)
            tag_at_head=$(git tag --points-at HEAD | head -n1 || true)
            if [ -n "$tag_at_head" ]; then
              commit_message="$(git for-each-ref --format='%(contents:subject)' refs/tags/$tag_at_head 2>/dev/null | tr -d '\r' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
            fi
          fi

          # safe base64-encoded output to avoid quote injection when used in later shell blocks
          commit_message_b64=$(printf '%s' "$commit_message" | base64 -w0)
          echo "commit_message_b64=$commit_message_b64" >> "$GITHUB_OUTPUT"

      - name: Decide whether to publish
        id: decide
        run: |
          # decode base64 commit message safely
          commit_message=$(printf '%s' "${{ steps.get_message.outputs.commit_message_b64 }}" | base64 --decode)

          # First try to find a version in the commit message
          if echo "$commit_message" | grep -qE '^v?[0-9]+\.[0-9]+\.[0-9]+'; then
            ver=$(echo "$commit_message" | grep -oE '^v?[0-9]+\.[0-9]+\.[0-9]+' | head -n1)
            source="commit"
          else
            # If no version in commit, check if this is a tag push (GITHUB_REF like refs/tags/v1.2.3)
            if [[ "${GITHUB_REF##*/}" =~ ^v?[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              ver="${GITHUB_REF##*/}"
              source="tag"
            else
              ver=""
              source="none"
            fi
          fi

          if [[ -n "$ver" ]]; then
            if [[ $ver != v* ]]; then ver="v$ver"; fi

            # If the version was derived from a tag, verify the tag signature using the GitHub API
            if [[ "$source" == "tag" ]]; then
              if [[ -z "${{ secrets.PERSONAL_TOKEN }}" ]]; then
                echo "Error: PERSONAL_TOKEN secret is not set; cannot verify tag signature" >&2
                exit 1
              fi

              repo="${{ github.repository }}"
              tag_name="$ver"
              # strip leading v for ref lookup
              tag_ref_name="${tag_name#v}"

              ref_json=$(curl -s -H "Authorization: token ${{ secrets.PERSONAL_TOKEN }}" "https://api.github.com/repos/$repo/git/refs/tags/$tag_ref_name")
              obj_sha=$(echo "$ref_json" | jq -r '.object.sha // empty')
              obj_type=$(echo "$ref_json" | jq -r '.object.type // empty')

              if [[ -z "$obj_sha" ]]; then
                echo "Error: could not resolve tag '$tag_ref_name' via GitHub API" >&2
                exit 1
              fi

              if [[ "$obj_type" == "tag" ]]; then
                tag_obj=$(curl -s -H "Authorization: token ${{ secrets.PERSONAL_TOKEN }}" "https://api.github.com/repos/$repo/git/tags/$obj_sha")
                verified=$(echo "$tag_obj" | jq -r '.verification.verified // false')
              else
                commit_obj=$(curl -s -H "Authorization: token ${{ secrets.PERSONAL_TOKEN }}" "https://api.github.com/repos/$repo/commits/$obj_sha")
                verified=$(echo "$commit_obj" | jq -r '.commit.verification.verified // false')
              fi

              if [[ "$verified" != "true" ]]; then
                echo "Error: tag '$tag_name' is not GPG-signed & verified by GitHub. Refusing to publish." >&2
                exit 1
              fi
            fi

            echo "publish=true" >> "$GITHUB_OUTPUT"
            echo "version=$ver" >> "$GITHUB_OUTPUT"
            # Use commit message for release body when present, otherwise note the source
            if [[ -n "$commit_message" ]]; then
              echo "release_body=$commit_message" >> "$GITHUB_OUTPUT"
            else
              echo "release_body=Release generated from $source $ver" >> "$GITHUB_OUTPUT"
            fi
            echo "commit_sha=$(git rev-parse HEAD)" >> "$GITHUB_OUTPUT"
          else
            echo "publish=false" >> "$GITHUB_OUTPUT"
            echo "version=" >> "$GITHUB_OUTPUT"
            echo "release_body=" >> "$GITHUB_OUTPUT"
            echo "commit_sha=" >> "$GITHUB_OUTPUT"
          fi

      - name: Verify version consistency
        if: ${{ steps.decide.outputs.publish == 'true' }}
        id: verify_version
        run: |
          # read version from internal/version/version.go
          FILE_VER=$(perl -ne 'if(/var\s+Version\s*=\s*"([^"]+)"/){print $1; exit}' internal/version/version.go || true)
          if [ -z "$FILE_VER" ]; then
            echo "Could not read version from internal/version/version.go; aborting" >&2
            exit 1
          fi
          # normalize expected version from commit message
          EXP_VER="${{ steps.decide.outputs.version }}"
          if [[ $EXP_VER != v* ]]; then EXP_VER="v$EXP_VER"; fi
          if [[ "$FILE_VER" != "$EXP_VER" ]]; then
            echo "Version mismatch: commit message version is $EXP_VER but internal/version/version.go contains $FILE_VER" >&2
            exit 1
          fi
          echo "Version consistency check passed: $FILE_VER"

  build:
    name: Build artifacts (all platforms)
    needs: check
    if: needs.check.outputs.publish == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.25.5'

      - name: Build distributions (portable)
        run: |
          set -euo pipefail
          mkdir -p dist
          # Read version from internal/version/version.go and use it as source of truth
          FILE_VER=$(perl -ne 'if(/var\s+Version\s*=\s*"([^"]+)"/){print $1; exit}' internal/version/version.go || true)
          if [ -z "$FILE_VER" ]; then
            echo "Could not read version from internal/version/version.go; aborting" >&2
            exit 1
          fi
          echo "Using version from version.go: $FILE_VER"
          VERSION_NO_V="${FILE_VER#v}"

          targets=("linux/amd64" "linux/arm64" "darwin/amd64" "darwin/arm64" "windows/amd64" "windows/arm64")
          for t in "${targets[@]}"; do
            os=${t%%/*}
            arch=${t##*/}
            ext=""
            if [ "$os" = "windows" ]; then ext=".exe"; fi
            out="dist/krnr-${VERSION_NO_V}-${os}-${arch}${ext}"
            echo "Building $out"
            env GOOS=$os GOARCH=$arch CGO_ENABLED=0 go build -ldflags "-X github.com/VoxDroid/krnr/internal/version.Version=${VERSION_NO_V}" -o "$out" .
          done

          # Create portable archives (named with '-portable') next to the binaries
          mkdir -p dist/portable
          for f in dist/krnr-${VERSION_NO_V}-*; do
            base=$(basename "$f")
            if [[ "$base" == *.exe ]]; then
              echo "Creating ZIP portable for $base"
              zip -j "dist/${base%.*}-portable.zip" "dist/$base" LICENSE README.md || true
            else
              echo "Creating tar.gz portable for $base"
              tar -C dist -czf "dist/${base}-portable.tar.gz" "$base" LICENSE README.md || true
            fi
          done

          # Move raw binaries into an artifacts subdir for cleanliness
          mkdir -p dist/portable/binaries
          mv dist/krnr-${VERSION_NO_V}-* dist/portable/binaries/ || true

      - name: Require PERSONAL_TOKEN
        run: |
          if [ -z "${{ secrets.PERSONAL_TOKEN }}" ]; then
            echo "PERSONAL_TOKEN secret is required to create a release under your account. Add it to repository secrets and re-run." >&2
            exit 1
          fi

      - name: Create annotated tag for release
        if: ${{ needs.check.outputs.publish == 'true' }}
        env:
          GITHUB_REPO: ${{ github.repository }}
          PERSONAL_TOKEN: ${{ secrets.PERSONAL_TOKEN }}
        run: |
          set -euo pipefail
          VERSION="${{ needs.check.outputs.version }}"
          echo "Creating and pushing tag $VERSION"
          git config user.name "VoxDroid"
          git config user.email "izeno.contact@gmail.com"
          git tag -a "$VERSION" -m "Release $VERSION"
          git push "https://x-access-token:${PERSONAL_TOKEN}@github.com/${GITHUB_REPO}" "$VERSION"

      - name: Install GoReleaser
        if: ${{ needs.check.outputs.publish == 'true' }}
        run: |
          curl -sSfL https://github.com/goreleaser/goreleaser/releases/latest/download/goreleaser_Linux_x86_64.tar.gz | tar xz -C /tmp
          sudo mv /tmp/goreleaser /usr/local/bin/

      - name: Run GoReleaser (snapshot - do not publish)
        if: ${{ needs.check.outputs.publish == 'true' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          echo "Removing old dist/ and running GoReleaser in snapshot mode (do not publish)"
          rm -rf dist || true
          goreleaser release --snapshot

      - name: Upload dist artifact
        if: ${{ needs.check.outputs.publish == 'true' }}
        id: upload_dist
        uses: actions/upload-artifact@v4
        with:
          name: dist
          path: dist/

      - name: Confirm built artifacts
        run: |
          echo "Artifacts packaged in dist/"
          ls -la dist || true

  build-msi:
    name: Build MSI (Windows)
    needs: check
    if: needs.check.outputs.publish == 'true'
    runs-on: windows-latest
    outputs:
      msi-sha: ${{ steps.compute.outputs.sha }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.25.5'

      - name: Install WiX Toolset
        shell: powershell
        run: |
          choco install wixtoolset -y

      - name: Build windows executable
        shell: bash
        run: |
          set -euo pipefail
          VERSION="${{ needs.check.outputs.version }}"
          VERSION_NO_V="${VERSION#v}"
          echo "Building krnr.exe for Windows (${VERSION_NO_V})"
          mkdir -p build
          env GOOS=windows GOARCH=amd64 CGO_ENABLED=0 go build -ldflags "-X github.com/VoxDroid/krnr/internal/version.Version=${VERSION}" -o build/krnr.exe .

      - name: Build MSI (PowerShell)
        shell: pwsh
        run: |
          # Normalize and validate release tag into a 4-part numeric ProductVersion suitable for WiX/MSI
          $raw = "${{ needs.check.outputs.version }}"
          $ver = $raw.TrimStart('v')
          if ([string]::IsNullOrWhiteSpace($ver)) { Write-Error "Release version is empty ($raw)"; exit 1 }

          # Split into numeric parts and validate
          $parts = $ver -split '\.'
          $num = @()
          foreach ($p in $parts) {
            if (-not ($p -match '^[0-9]+$')) { Write-Error "Invalid version part '$p' in version '$ver'"; exit 1 }
            $num += [int]$p
          }

          # Pad to 4 parts with zeros, fail if more than 4 parts
          while ($num.Count -lt 4) { $num += 0 }
          if ($num.Count -gt 4) { Write-Error "Version '$ver' has too many components; expected at most 4"; exit 1 }

          # Validate numeric ranges (0..65534 as a conservative limit)
          foreach ($n in $num) { if ($n -lt 0 -or $n -gt 65534) { Write-Error "Version component out of range: $n"; exit 1 } }

          $productVersion = "$($num[0]).$($num[1]).$($num[2]).$($num[3])"
          Write-Host "ProductVersion: $productVersion"

          .\packaging\windows\wix\build.ps1 -BuildOutputPath "${{ github.workspace }}\build" -ProductVersion $productVersion

      - name: Compute MSI SHA
        id: compute
        shell: pwsh
        run: |
          $msi = Get-ChildItem -Path 'packaging' -Filter 'krnr-*.msi' -Recurse | Select-Object -First 1 -ExpandProperty FullName
          if (-not $msi) { Write-Error "MSI not found"; exit 1 }
          $sha = (Get-FileHash -Path $msi -Algorithm SHA256).Hash.ToUpper()
          Write-Host "MSI: $msi"
          Write-Host "SHA256: $sha"
          echo "sha=$sha" >> $env:GITHUB_OUTPUT

      - name: Copy MSI to root for artifact upload
        shell: pwsh
        run: |
          $msi = Get-ChildItem -Path 'packaging' -Filter 'krnr-*.msi' -Recurse | Select-Object -First 1 -ExpandProperty FullName
          if ($msi) {
            Write-Host "Copying MSI to workspace root: $msi"
            $destination = Join-Path $env:GITHUB_WORKSPACE (Split-Path -Leaf $msi)
            Copy-Item -Path $msi -Destination $destination -Force
            Write-Host "MSI copied to: $destination"
            if (Test-Path $destination) {
              Write-Host "MSI file size: $((Get-Item $destination).Length) bytes"
            }
          } else {
            Write-Error "No MSI found to copy"
            exit 1
          }

      - name: Upload MSI artifact
        uses: actions/upload-artifact@v4
        with:
          name: krnr-msi
          path: krnr-*.msi

  publish-all:
    name: Publish all artifacts to Release
    needs: [check, build, build-msi]
    if: needs.check.outputs.publish == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository (required by GoReleaser)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download dist artifact
        uses: actions/download-artifact@v4
        with:
          name: dist
          path: dist-download

      - name: Download MSI artifact
        uses: actions/download-artifact@v4
        with:
          name: krnr-msi
          path: msi-download

      - name: List downloaded artifacts
        run: |
          echo "=== Contents of dist-download ==="
          ls -laR dist-download || echo "dist-download is empty"
          echo ""
          echo "=== Contents of msi-download ==="
          ls -laR msi-download || echo "msi-download is empty"
          echo ""
          echo "=== Looking for MSI files ==="
          find . -type f -name "*.msi" -ls || echo "No MSI files found"

      - name: Require PERSONAL_TOKEN
        run: |
          if [ -z "${{ secrets.PERSONAL_TOKEN }}" ]; then
            echo "PERSONAL_TOKEN secret is required to upload artifacts to the GitHub Release. Add it to repository secrets and re-run." >&2
            exit 1
          fi

      - name: Install GoReleaser
        run: |
          curl -sSfL https://github.com/goreleaser/goreleaser/releases/latest/download/goreleaser_Linux_x86_64.tar.gz | tar xz -C /tmp
          sudo mv /tmp/goreleaser /usr/local/bin/
          echo "goreleaser version: $(goreleaser --version || true)"

      - name: Prepare release notes
        run: |
          NOTES_FILE=$(mktemp)
          if [ -n "${{ needs.check.outputs.release_body }}" ]; then
            echo "${{ needs.check.outputs.release_body }}" > "$NOTES_FILE"
          else
            echo "Release ${{ needs.check.outputs.version }}" > "$NOTES_FILE"
          fi
          echo "NOTES_FILE=$NOTES_FILE" >> $GITHUB_ENV

      - name: Preserve MSI files before cleaning
        run: |
          set -euo pipefail
          echo "Moving MSI files to temporary location"
          mkdir -p /tmp/msi-backup
          find msi-download -type f -name "krnr-*.msi" -exec cp {} /tmp/msi-backup/ \; || true
          ls -la /tmp/msi-backup/ || echo "No MSI files backed up"

      - name: Clean downloaded artifacts to avoid dirty git state
        run: |
          set -euo pipefail
          echo "Removing downloaded artifact directories"
          rm -rf dist-download msi-download || true
          git status

      - name: Run GoReleaser (publish)
        env:
          GITHUB_TOKEN: ${{ secrets.PERSONAL_TOKEN }}
        run: |
          set -euo pipefail
          echo "Running GoReleaser to publish all artifacts"
          goreleaser release --release-notes "$NOTES_FILE"

      - name: Upload MSI files to GitHub Release
        env:
          GITHUB_REPO: ${{ github.repository }}
          PERSONAL_TOKEN: ${{ secrets.PERSONAL_TOKEN }}
          TAG: ${{ needs.check.outputs.version }}
        run: |
          set -euo pipefail

          echo "Looking for MSI files to upload"

          # Find MSI files from backup location
          if [ ! -d "/tmp/msi-backup" ]; then
            echo "No MSI backup directory found"
            exit 1
          fi

          msi_files=$(find /tmp/msi-backup -type f -name "krnr-*.msi" 2>/dev/null || true)

          if [ -z "$msi_files" ]; then
            echo "No MSI files found in backup directory"
            exit 1
          fi

          # Get release information
          releaseJson=$(curl -s -H "Authorization: token $PERSONAL_TOKEN" "https://api.github.com/repos/$GITHUB_REPO/releases/tags/$TAG" || true)
          uploadUrl=$(echo "$releaseJson" | jq -r '.upload_url // empty' | sed 's/{.*}//')
          releaseId=$(echo "$releaseJson" | jq -r '.id // empty')

          if [ -z "$uploadUrl" ] || [ "$uploadUrl" == "null" ]; then
            echo "Release for tag $TAG not found; aborting" >&2
            exit 1
          fi

          echo "Release ID: $releaseId"
          echo "Upload URL: $uploadUrl"

          # Get version without 'v' prefix
          VERSION_NO_V="${TAG#v}"

          # Upload each MSI file
          for msi_path in $msi_files; do
            if [ -f "$msi_path" ]; then
              original_name=$(basename "$msi_path")
              echo "Found MSI: $original_name (from $msi_path)"

              # Rename to format: krnr_X.Y.Z_windows_installer.msi
              # Remove trailing .0 ONLY if version is X.Y.Z.0 (i.e., drop a fourth component)
              clean_version=$(echo "$VERSION_NO_V" | sed -E 's/^([0-9]+\.[0-9]+\.[0-9]+)\.0$/\1/')
              new_name="krnr_${clean_version}_windows_installer.msi"

              echo "Renaming: $original_name -> $new_name"

              # Calculate SHA256
              sha=$(sha256sum "$msi_path" | awk '{print toupper($1)}')
              echo "SHA256: $sha"

              # Upload the MSI file with new name
              upload_response=$(curl -s -X POST \
                -H "Authorization: token $PERSONAL_TOKEN" \
                -H "Content-Type: application/octet-stream" \
                --data-binary @"$msi_path" \
                "$uploadUrl?name=$new_name")

              upload_state=$(echo "$upload_response" | jq -r '.state // empty')
              if [ "$upload_state" == "uploaded" ]; then
                echo "✓ Successfully uploaded $new_name"
              else
                echo "✗ Failed to upload $new_name"
                echo "Response: $upload_response"
              fi
            fi
          done

      - name: Final release listing
        run: |
          echo "=== Release assets uploaded ==="
          TAG="${{ needs.check.outputs.version }}"
          curl -s -H "Authorization: token ${{ secrets.PERSONAL_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/releases/tags/$TAG" \
            | jq -r '.assets[] | "- \(.name) (\(.size) bytes)"' || echo "Could not list assets"
